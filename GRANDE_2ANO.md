# Semestre 3 (6 disciplinas)

## Algoritmos e Estruturas de Dados II
**Objetivo de engenharia:** Capacitar o engenheiro a projetar soluções eficientes para problemas complexos, avaliando custo computacional, escalabilidade e limites práticos de estruturas não lineares.

**Competências (K+S+D):**
- K: árvores balanceadas, grafos, hashing, análise assintótica avançada
- S: selecionar e implementar estruturas adequadas ao domínio do problema
- D: obsessão por eficiência, rigor analítico

**Ementa:** Estruturas de dados não lineares, algoritmos avançados de busca, ordenação e grafos, análise de complexidade e trade-offs de implementação.

**Conteúdo Programático:**
- Árvores (AVL, Red-Black, B-Trees)
- Heaps e filas de prioridade
- Hashing e colisões
- Grafos: representações e algoritmos (BFS, DFS, Dijkstra, MST)
- Análise de complexidade temporal e espacial

**Dependências:** Algoritmos e Estruturas de Dados I, Matemática Discreta II

**Entregáveis:** Biblioteca de estruturas implementadas + relatório comparativo de desempenho

**Bibliografia:**
- Cormen et al.
- Sedgewick
  
**Método de estudo:** Implementação + benchmarks + análise formal

## Programação III (Genérica e Funcional)
**Objetivo de engenharia:** Ampliar o repertório cognitivo do engenheiro, capacitando-o a escolher paradigmas conforme o domínio do problema, reduzindo complexidade acidental.

**Competências (K+S+D):**
- K: programação funcional, tipos genéricos, polimorfismo avançado
- S: escrever código declarativo, reutilizável e testável
- D: abertura a novos modelos mentais

**Ementa:** Paradigmas funcional e genérico aplicados à construção de software robusto.

**Conteúdo Programático:**
- Funções puras e imutabilidade
- Tipos paramétricos e genéricos
- Funções de alta ordem
- Map/Reduce, pipelines
- Comparação entre paradigmas

**Dependências:** Programação II, Matemática Discreta I

**Entregáveis:** Biblioteca funcional reutilizável

**Bibliografia:**
- Pierce
- Okasaki

**Método de estudo:** Exercícios conceituais + refatoração de código imperativo

## Arquitetura de Computadores
**Objetivo de engenharia:** Compreender profundamente como software é executado em hardware, permitindo decisões conscientes sobre performance, concorrência e uso de recursos.

**Competências (K+S+D):**
- K: CPU, memória, pipeline, paralelismo
- S: correlacionar código e comportamento da máquina
- D: respeito aos limites físicos
  
**Ementa:** Organização e arquitetura de computadores modernos.

**Conteúdo Programático:**
- Representação de dados
- Arquitetura de CPU
- Pipeline e paralelismo
- Hierarquia de memória
- I/O e interrupções

**Dependências:** Fundamentos de Computação e Sistemas, Cálculo I

**Entregáveis:** Análise de execução de programas em baixo nível

**Bibliografia:**
- Patterson & Hennessy

**Método de estudo:** Análise de assembly + simulações

## Estatística e Probabilidade Aplicadas
**Objetivo de engenharia:** Capacitar o engenheiro a tomar decisões técnicas baseadas em dados, incerteza e variabilidade real de sistemas.

**Competências (K+S+D):**
- K: probabilidade, inferência, distribuições
- S: análise de dados experimentais
- D: pensamento crítico baseado em evidências
  
**Ementa:** Estatística aplicada à engenharia de software.

**Conteúdo Programático:**
- Variáveis aleatórias
- Distribuições
- Inferência estatística
- Testes de hipótese
- Análise de métricas de software
  
**Dependências:** Cálculo Diferencial e Integral I
  
**Entregáveis:** Relatórios estatísticos de experimentos de software
  
**Bibliografia:**
- Montgomery

**Método de estudo:** Experimentos reais + análise quantitativa

## Modelagem e Análise de Software
**Objetivo de engenharia:** Capacitar o engenheiro a representar sistemas complexos de forma compreensível, verificável e comunicável.

**Competências (K+S+D):**
- K: UML, modelagem conceitual
- S: abstrair e comunicar sistemas
- D: clareza e precisão
  
**Ementa:** Modelagem estrutural e comportamental de sistemas.

**Conteúdo Programático:**
- Modelos conceituais
- Diagramas UML
- Análise de domínio
- Casos de uso
- Modelagem de comportamento
  
**Dependências:** Programação II, Comunicação Técnica

**Entregáveis:** Modelo completo de sistema real

**Bibliografia:**
- Larman

**Método de estudo:** Modelagem de sistemas reais

## Sistemas Operacionais
**Objetivo de engenharia:** Entender como sistemas gerenciam recursos, processos e concorrência, impactando diretamente confiabilidade e performance.

**Competências (K+S+D):**
- K: processos, threads, memória
- S: análise de concorrência
- D: rigor e disciplina
  
**Ementa:** Fundamentos e arquitetura de sistemas operacionais modernos.

**Conteúdo Programático:**
- Processos e threads
- Escalonamento
- Gerenciamento de memória
- Sistemas de arquivos
- Concorrência e deadlocks
  
**Dependências:** Arquitetura de Computadores, Programação III

**Entregáveis:** Relatórios de experimentos em SO

**Bibliografia:**
- Tanenbaum

**Método de estudo:** Laboratórios práticos

# Semestre 4 (6 disciplinas)

## Engenharia de Requisitos
**Objetivo de engenharia:** Capacitar o engenheiro a transformar necessidades humanas e organizacionais ambíguas em especificações rastreáveis, testáveis e negociáveis.

**Competências (K+S+D):**
- K: tipos de requisitos, NFRs, rastreabilidade
- S: elicitar, documentar, validar
- D: escuta ativa, rigor, negociação

**Ementa:** Fundamentos de requisitos, elicitação, análise, especificação, validação e gerenciamento de mudanças.

**Conteúdo Programático:**
- Stakeholders e contexto
- Técnicas de elicitação
- Requisitos funcionais e não funcionais
- Modelagem (Casos de Uso, User Stories)
- Rastreabilidade e versionamento

**Dependências:** Modelagem e Análise de Software

**Entregáveis:** Documento de requisitos + matriz de rastreabilidade

**Bibliografia:**
- Sommerville
- Leffingwell & Widrig
  
**Método de estudo:** Casos reais + entrevistas simuladas

## Bancos de Dados I (Modelagem e SQL)
**Objetivo de engenharia:** Capacitar o engenheiro a projetar, validar e operar modelos de dados consistentes, evolutivos e alinhados a sistemas reais, entendendo persistência como decisão arquitetural crítica.

**Competências (K+S+D):**
K: modelo relacional, álgebra relacional, normalização, transações, integridade
S: modelar domínios reais, escrever consultas eficientes, projetar esquemas versionáveis
D: rigor estrutural, aversão a ambiguidade, responsabilidade com dados

**Ementa:** Fundamentos de bancos de dados relacionais, modelagem conceitual e lógica, normalização, SQL, integridade, transações e introdução à evolução de esquemas.

**Conteúdo Programático:**
- Dados como ativo organizacional
- Modelagem conceitual (ER estendido)
- Modelagem lógica relacional
- Normalização (1FN–5FN) e trade-offs
- Álgebra relacional e fundamentos de consulta
- SQL: DDL, DML, constraints
- Transações, ACID e isolamento
- Versionamento e migração de esquemas

**Dependências explícitas:**
- Algoritmos e Estruturas de Dados I
- Modelagem e Análise de Software

**Entregáveis:**
- Modelo conceitual e lógico de um domínio real
- Esquema relacional versionado
- Conjunto de consultas críticas documentadas

**Bibliografia:**
- Elmasri & Navathe — Fundamentals of Database Systems
- Date — An Introduction to Database Systems

**Método de estudo:** Modelagem de sistemas reais (financeiro, logístico, saúde), revisão cruzada de modelos, testes de integridade e falhas simuladas.

## Redes de Computadores
**Objetivo de engenharia:** Capacitar o engenheiro a compreender, diagnosticar e projetar comunicação entre sistemas, considerando latência, falhas e protocolos reais da internet.

**Competências (K+S+D):**
- K: modelos OSI/TCP-IP, protocolos, roteamento
- S: análise de tráfego, diagnóstico de falhas
- D: precisão técnica, pensamento sistêmico

**Ementa:** Fundamentos de redes, protocolos de comunicação, arquitetura da internet, análise de tráfego e impacto no software.

**Conteúdo Programático:**
- Comunicação como contrato
- Modelos OSI e TCP/IP
- IP, TCP, UDP
- HTTP/HTTPS e APIs
- DNS, NAT, roteamento
- Latência, perda e jitter
- Falhas de rede em sistemas distribuídos

**Dependências explícitas:**
- Sistemas Operacionais
- Arquitetura de Computadores

**Entregáveis:**
- Análise de tráfego real (packet capture)
- Relatório de falha de comunicação

**Bibliografia:**
- Kurose & Ross — Computer Networking

**Método de estudo:** Laboratórios com captura de pacotes, simulação de falhas, análise de incidentes reais.

## Interface Humano-Computador
**Objetivo de engenharia:** Projetar interfaces que reduzam erro humano, aumentem eficiência e respeitem limitações cognitivas reais.

**Competências (K+S+D):**
- K: cognição humana, heurísticas de usabilidade
- S: prototipar, testar, avaliar
- D: empatia técnica, responsabilidade social

**Ementa:** Fundamentos de IHC, usabilidade, acessibilidade, avaliação empírica de interfaces.

**Conteúdo Programático:**
- Interface como sistema crítico
- Modelos mentais e carga cognitiva
- Heurísticas de Nielsen
- Prototipação de média fidelidade
- Testes de usabilidade
- Acessibilidade e inclusão

**Dependências explícitas:**
- Engenharia de Requisitos
- Modelagem e Análise de Software

**Entregáveis:**
- Protótipo testado
- Relatório de usabilidade com métricas

**Bibliografia:**
- Nielsen — Usability Engineering
- Norman — The Design of Everyday Things

**Método de estudo:** Testes com usuários reais, análise de falhas de interface críticas.

## Métodos Formais Aplicados
**Objetivo de engenharia:** Capacitar o engenheiro a especificar, verificar e provar propriedades críticas de sistemas antes da implementação.

**Competências (K+S+D):**
- K: lógica formal, especificação, verificação
- S: modelar formalmente sistemas
- D: rigor extremo, disciplina intelectual

**Ementa:** Lógica formal aplicada, especificação matemática e verificação de propriedades de software.

**Conteúdo Programático:**
- Por que programas falham
- Lógica proposicional e de predicados
- Especificação formal
- Invariantes e pré/pós-condições
- Verificação de modelos

**Dependências explícitas:**
- Matemática Discreta II
- Lógica de Programação

**Entregáveis:**
- Especificação formal de sistema crítico
- Prova de propriedades selecionadas

**Bibliografia:**
- Wing — A Specifier’s Introduction to Formal Methods

**Método de estudo:** Exercícios formais, análise de falhas catastróficas evitáveis.

## Programação Concorrente e Paralela
**Objetivo de engenharia:** Capacitar o engenheiro a projetar e implementar software correto e eficiente sob execução concorrente e paralela.

**Competências (K+S+D):**
- K: concorrência, paralelismo, sincronização
- S: projetar código thread-safe
- D: paranoia saudável, rigor extremo

**Ementa:** Fundamentos de concorrência, paralelismo, sincronização e modelos de execução.

**Conteúdo Programático:**
- Concorrência vs paralelismo
- Threads, processos e memória compartilhada
- Condições de corrida e deadlocks
- Mutexes, semáforos, monitores
- Modelos de memória
- Paralelismo em sistemas modernos

**Dependências explícitas:**
- Sistemas Operacionais
- Programação III

**Entregáveis:**
- Sistema concorrente com falhas induzidas
- Relatório de correção e desempenho

**Bibliografia:**
- Goetz — Java Concurrency in Practice
- Herlihy — The Art of Multiprocessor Programming

**Método de estudo** Laboratórios com race conditions reais, análise de bugs clássicos.
